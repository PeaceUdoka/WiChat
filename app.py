# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ftsZYXXxAvc2CCtA2FcgYYtpj-xCjqQj
"""

!pip install -qU langchain
!pip install -qU transformers
!pip install -qU langchain-community
!pip install -qU unstructured
!pip install -qU sentence-transformers
!pip install -qU faiss-cpu
!pip install -qU langchain_openai
!pip install -qU openai streamlit pyttsx3 SpeechRecognition

import openai
import os
import pyttsx3
import streamlit as st
import time
import speech_recognition as sr
from threading import Thread
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.chains.combine_documents import create_stuff_documents_chain
from langchain.chains import create_retrieval_chain
from langchain.embeddings import HuggingFaceEmbeddings
from langchain.vectorstores import FAISS
from langchain.document_loaders import DirectoryLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chains import create_history_aware_retriever
from langchain_community.chat_message_histories import ChatMessageHistory
from langchain_core.runnables.history import RunnableWithMessageHistory
from langchain_core.output_parsers import StrOutputParser

# Commented out IPython magic to ensure Python compatibility.
#move to the folder where the scraped data is on your device
from google.colab import drive
drive.mount('/content/drive')
# %cd /content/drive/MyDrive/Data/WiChat

#API_KEY = os.environ["OPENAI_API_KEY"]
#openai.apikey = APIKEY
import os
key = os.environ['OPENAI_API_KEY']

def load_data(path):
    loader1 = DirectoryLoader(path, glob='*.txt', show_progress=True)
    docs = loader1.load()
    return docs

def get_chunks(docs):
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=150)
    chunks = text_splitter.split_documents(docs)
    return chunks

# embed data sources
def embed(data, device, model):
  model_kwargs = {'device': device}
  encode_kwargs = {'normalize_embeddings': False}

  embeddings = HuggingFaceEmbeddings(
    model_name = model,
    model_kwargs = model_kwargs,
    encode_kwargs = encode_kwargs
  )
  return embeddings

path = '/content/drive/MyDrive/Data/WiChat/scraped_data'
#path = 'scraped_data'
docs = load_data(path)
data = get_chunks(docs)


def store_data(data, embeddings):
  # vector store
  db = FAISS.from_documents(data, embeddings)
  return db

embeddings = embed(data, 'cpu', 'sentence-transformers/all-MiniLM-L6-v2')
db = store_data(data, embeddings)

# cache the model
@st.cache_resource
def load_model():
    return ChatOpenAI(model="gpt-4o")

llm = load_model()

# Define the chat prompt
prompt = ChatPromptTemplate.from_messages(
    [
        ("system","You are called WiChat, which is short for Worldbank Ideas Chatbot, the chatbot for the Worldbank Ideas Project. You are friendly and follow instructions to answer questions extremely well. Please be truthful and give direct answers. If you don't know the answer, just say that you don't know, don't try to make up an answer. Keep the response short and concise in at most five sentences. If the user chats in a different language, translate accurately and respond in the same language. You will provide specific details and accurate answers to user queries on the Worldbank Ideas Project."),
        MessagesPlaceholder("chat_history"),
        ("human", "Use only the retrieved {context} to answer the user question {input}.")
    ]
)

# --- Create RAG chain ---

contextualize_q_system_prompt = """Given a chat history and the latest user question \
which might reference context in the chat history, formulate a standalone question \
which can be understood without the chat history. Do NOT answer the question, \
just reformulate it if needed and otherwise return it as is."""
contextualize_q_prompt = ChatPromptTemplate.from_messages(
    [
        ("system", contextualize_q_system_prompt),
        MessagesPlaceholder("chat_history"),
        ("human", "{input}"),
    ]
)

### manage chat history ###

st.session_state.chat_history = {}

def get_session_history(session_id: str):
    if session_id not in st.session_state.chat_history:
        st.session_state.chat_history[session_id] = ChatMessageHistory()
    return st.session_state.chat_history[session_id]

retriever = db.as_retriever(search_type="similarity", search_kwargs={"k": 3})

history_aware_retriever = create_history_aware_retriever(llm, retriever, contextualize_q_prompt)

question_answer_chain = create_stuff_documents_chain(llm, prompt)

rag_chain = create_retrieval_chain(history_aware_retriever, question_answer_chain)

conversational_rag_chain = RunnableWithMessageHistory(
    rag_chain,
    get_session_history,
    input_messages_key="input",
    history_messages_key="chat_history",
    output_messages_key="answer",
)

# --- Response Generation ---
def generate_response(query):
    return conversational_rag_chain.invoke({"input": query}, config={"configurable": {"session_id": "1"}})["answer"]

# Startup Screen
def startup_screen():
    st.image("/content/drive/MyDrive/Data/WiChat/scraped_data/Wichat2.png", use_container_width=True)
    st.spinner("Loading...")  # Spinner while loading
    time.sleep(3)
    st.title("WiChat")
    st.subheader("Version 1.0")
    st.session_state.current_screen = "main"  # Switch to main screen after loading

# Login Screen
def login_screen():
    st.title("Login")

    username_input = st.text_input("Username")
    password_input = st.text_input("Password", type="password")

    login_button = st.button("Login")

    if login_button:

        if username_input and password_input:
            st.success("Logged in successfully!")
            st.session_state.current_screen = "main"  # Switch to main screen on successful login
            st.rerun()
        else:
            st.error("Invalid credentials. Please try again.")

    back_button = st.button("Back")

    if back_button:
        st.session_state.current_screen = "startup"  # Go back to startup screen
        st.rerun()

def signup_screen():

    st.title("Sign Up")

    # Input fields for signup
    username = st.text_input("Username", key="signup_username")
    password = st.text_input("Password", type="password", key="signup_password")
    confirm_password = st.text_input("Confirm Password", type="password", key="signup_confirm_password")
    email = st.text_input("Email", key="signup_email")

    signup_button = st.button("Sign Up")

    if signup_button:
        if password == confirm_password:

            st.success(f"Account created successfully for {username} with email {email}!")
            # navigate back to the chat screen or login screen
            st.session_state.current_screen = "login"
            st.rerun()
        else:
            st.error("Passwords do not match. Please try again.")

    back_button = st.button("Back to Login")
    if back_button:
        st.session_state.current_screen = "login"
        st.rerun()

# Function to display the menu
def show_menu():
    """Displays the menu options using a selectbox."""
    menu_options = ["Clear Chat", "Help"]
    selected_option = st.selectbox("Menu Options", menu_options)
    if selected_option:
        menu_callback(selected_option)

# Function to display the account options
def show_account():
    """Displays the account options (Login/SignUp) using a selectbox."""
    account_options = ["Login", "SignUp"]
    selected_option = st.selectbox("Account Options", account_options)
    if selected_option:
        account_callback(selected_option)

# Function to handle menu callback actions
def menu_callback(option):
    """Handles actions based on the menu option selected."""
    if option == "Clear Chat":
        clear_chat()
    elif option == "Help":
        st.info("Help: Contact support for assistance.")

# Function to handle account callback actions
def account_callback(option):
    """Handles account actions (Login/SignUp) and manages screen transitions."""
    if option == "Login":
        st.session_state.current_screen = "login"

    elif option == "SignUp":
        st.session_state.current_screen = "signup"


# Function to record audio
def record_audio():
    """Records audio, converts it to text, and updates the input field."""
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        st.write("Listening...")
        try:
            audio = recognizer.listen(source, timeout=5)
            user_input = recognizer.recognize_google(audio)

        except sr.UnknownValueError:
            st.error("Could not understand audio.")
        except sr.RequestError as e:
            st.error(f"Speech Recognition service error: {e}")

        return user_input

# Function to speak text
def speak_text(response):
    """Converts text to speech using pyttsx3."""
    engine = pyttsx3.init()
    engine.say(response)
    engine.runAndWait()

# Function to send a message to chatbot
def send_message(user_input):
    """Sends a message to the chatbot and updates the chat history."""
    if user_input:
        # Append user message to the chat history
        st.session_state.chat_history.append({"type": "user", "content": user_input})

        # Generate response from the chatbot
        response = st.write_stream(generate_response(user_input))

        # Append chatbot response to the chat history
        st.session_state.chat_history.append({"type": "assistant", "content": response})

        # Clear the input field
        st.session_state.user_input = ""

        return(response)
# Function to clear the chat history
def clear_chat():
    """Clears the chat history."""
    st.session_state.chat_history = {}

# ------------------------- Streamlit UI -------------------------
def main():

    # Initialize session state

    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = {}

    if 'current_screen' not in st.session_state:
      startup_screen()
    elif st.session_state.current_screen == "startup":
      startup_screen()
    elif st.session_state.current_screen == "login":
      login_screen()


    # Render UI based on the current screen
    if st.session_state.current_screen == "main":
        st.title("WiChat")


        # Welcome Card
        st.markdown("<div style='background-color: white; padding: 10px; border-radius: 10px;'><h4>Welcome!!! What would you like to know? </h4></div>", unsafe_allow_html=True)

       # Chat Display
        session_id = "1"  # Replace with a dynamic session ID if needed
        st.session_state.chat_history = get_session_history(session_id).messages

        # Display chat messages from history on app rerun
        for message in st.session_state.chat_history:
          with st.chat_message(message["role"]):
           st.markdown(message["content"])

        # Top bar menu
        col1, col2, col3 = st.columns([1, 4, 1])

        with col1:
            if st.button("Menu"):
                show_menu()
        with col3:
            if st.button("Account"):
                show_account()

        # Input section
        input_col1, input_col2, input_col3 = st.columns([8, 1, 1])

        with input_col1:
            user_input = st.text_input("", placeholder="Type your message...", key="input_text")

        with input_col2:
            if st.button("ðŸŽ¤", key="mic_button"):
                user_input = record_audio()
                response = send_message(user_input)
                speak_text(response)
        with input_col3:
            if st.button("Send"):
                send_message(user_input)


    elif st.session_state.current_screen == "login":
        # Render login screen
        login_screen()
    elif st.session_state.current_screen == "signup":
        # Render signup screen
        signup_screen()